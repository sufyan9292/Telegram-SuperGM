// Cloudflare Worker å…¥å£
export default {
  async fetch(request, env, ctx) {
    // Turnstile éªŒè¯é¡µé¢ & å›è°ƒ
    const url = new URL(request.url);
    if (url.pathname === '/verify') {
      if (request.method === 'GET') return renderVerifyPage(url, env);
      if (request.method === 'POST') return handleVerifySubmit(request, env);
    }

    if (request.method !== 'POST') return new Response('OK');

    let update;
    try {
      update = await request.json();
    } catch {
      return new Response('OK');
    }

    const msg = update.message;
    if (!msg) {
      return new Response('OK');
    }

    // ç§èŠ -> è¯é¢˜
    if (msg.chat && msg.chat.type === 'private') {
      await handlePrivateMessage(msg, env);
      return new Response('OK');
    }

    // ç¾¤å†…äº‹ä»¶ / è¯é¢˜ç›¸å…³
    const supergroupId = Number(env.SUPERGROUP_ID);
    if (msg.chat && Number(msg.chat.id) === supergroupId) {
      // è¯é¢˜è¢«å…³é—­
      if (msg.forum_topic_closed && msg.message_thread_id) {
        await markThreadClosed(msg.message_thread_id, env);
        return new Response('OK');
      }
      // è¯é¢˜é‡æ–°å¼€å¯
      if (msg.forum_topic_reopened && msg.message_thread_id) {
        await markThreadReopened(msg.message_thread_id, env);
        return new Response('OK');
      }
      // æ™®é€šè¯é¢˜æ¶ˆæ¯ â†’ ç§èŠ
      if (msg.message_thread_id) {
        await handleTopicMessage(msg, env);
        return new Response('OK');
      }
    }

    return new Response('OK');
  }
};

// ç§èŠæ¥çš„æ¶ˆæ¯ï¼šè½¬åˆ°å¯¹åº”è¯é¢˜ï¼ˆå¸¦å¼•ç”¨è½¬å‘ï¼‰
async function handlePrivateMessage(msg, env) {
  const userId = msg.chat.id;
  const key = `user:${userId}`;

  // è¿‡æ»¤ /start å‘½ä»¤
  if (msg.text && msg.text.trim().toLowerCase().startsWith('/start')) {
    return;
  }

  // Turnstile é¦–æ¬¡éªŒè¯ï¼ˆå¯é€‰ï¼‰
  if (env.TURNSTILE_SECRET && env.TURNSTILE_SITEKEY) {
    const verified = await isVerified(userId, env);
    if (!verified) {
      const token = crypto.randomUUID();
      // 15 åˆ†é’Ÿæœ‰æ•ˆ
      await env.TOPIC_MAP.put(`verify:${token}`, JSON.stringify({ uid: userId }), { expirationTtl: 900 });
      const base = env.PUBLIC_BASE; // è¯·åœ¨ç¯å¢ƒå˜é‡ä¸­é…ç½®å½¢å¦‚ https://tgbot.xxx.workers.dev
      if (base) {
        const link = `${base.replace(/\/$/, '')}/verify?token=${token}`;
        await tgCall(env, 'sendMessage', {
          chat_id: userId,
          text: [
            'âš ï¸ æ£€æµ‹åˆ°è¿™æ˜¯ä½ ç¬¬ä¸€æ¬¡ä½¿ç”¨ï¼Œè¯·å…ˆå®ŒæˆäººæœºéªŒè¯ï¼š',
            `ğŸ”— ${link}`,
            '',
            'è¯·åœ¨ç½‘é¡µä¸­çœ‹åˆ°â€œéªŒè¯æˆåŠŸï¼Œè¯·å›åˆ° Telegram ç»§ç»­å¯¹è¯â€æç¤ºåï¼Œ',
            'å†å›åˆ°è¿™é‡Œç»§ç»­å‘æ¶ˆæ¯ï¼Œå¦åˆ™ä¼šä¸€ç›´é‡å¤è¦æ±‚éªŒè¯ã€‚'
          ].join('\n')
        });
      }
      return;
    }
  }

  // 1. ä» KV å–è¯¥ç”¨æˆ·ç»‘å®šçš„è¯é¢˜
  let rec = await env.TOPIC_MAP.get(key, { type: 'json' });
  // å·²æœ‰è¯é¢˜ä½†è¢«å…³é—­ï¼šä¸å†æ¨é€ç¾¤ç»„ï¼Œåªæç¤ºç”¨æˆ·
  if (rec && rec.closed) {
    await tgCall(env, 'sendMessage', {
      chat_id: userId,
      text: 'å½“å‰è¯é¢˜å·²è¢«ç®¡ç†å‘˜å…³é—­ï¼Œå¦‚éœ€ç»§ç»­å¯¹è¯è¯·è”ç³»ç®¡ç†å‘˜æˆ–ç­‰å¾…é‡æ–°å¼€å¯ã€‚'
    });
    return;
  }

  // 2. æ²¡æœ‰å°±åˆ›å»ºæ–°è¯é¢˜å¹¶å­˜ KV
  if (!rec) {
    rec = await createAndStoreTopic(msg.from, key, env);
  }

  // 3. æŠŠç”¨æˆ·æ¶ˆæ¯â€œå¸¦å¼•ç”¨â€è½¬å‘åˆ°è¯é¢˜ä¸­
  //    ä½¿ç”¨ forwardMessageï¼Œä¼šæ˜¾ç¤ºã€Œè½¬å‘è‡ª XXXã€
  const res = await tgCall(env, 'forwardMessage', {
    chat_id: env.SUPERGROUP_ID,
    from_chat_id: userId,
    message_id: msg.message_id,
    message_thread_id: rec.thread_id
  });

  // å¦‚æœè¯é¢˜ä¸å­˜åœ¨/è¢«åˆ ï¼Œæœ‰å¯èƒ½è¿”å›å¤±è´¥ï¼Œè¿™é‡Œåªåœ¨â€œè¯é¢˜ä¸å­˜åœ¨â€æ—¶é‡å»º
  if (!res.ok) {
    if (isThreadMissingError(res)) {
      const newRec = await createAndStoreTopic(msg.from, key, env);
      await tgCall(env, 'forwardMessage', {
        chat_id: env.SUPERGROUP_ID,
        from_chat_id: userId,
        message_id: msg.message_id,
        message_thread_id: newRec.thread_id
      });
    }
  }
}

// è¯é¢˜é‡Œçš„æ¶ˆæ¯ï¼šè½¬å›å¯¹åº”ç”¨æˆ·ï¼ˆä¸å¸¦å¼•ç”¨ï¼Œéšè—èº«ä»½ï¼‰
async function handleTopicMessage(msg, env) {
  const threadId = msg.message_thread_id;

  // é¿å…æœºå™¨äººè‡ªå·±å‘çš„æ¶ˆæ¯å†å›ç»™ç”¨æˆ·å¯¼è‡´å¾ªç¯
  const botId = Number(env.BOT_ID || 0);
  if (msg.from && Number(msg.from.id) === botId) {
    return;
  }

  const userId = await findUserByThread(threadId, env);
  if (!userId) return;

  // ç”¨ copyMessage å¤åˆ¶æ¶ˆæ¯åˆ°ç§èŠï¼Œä¸å¸¦ã€Œè½¬å‘è‡ªã€
  await tgCall(env, 'copyMessage', {
    chat_id: userId,
    from_chat_id: env.SUPERGROUP_ID,
    message_id: msg.message_id
  });
}

// åˆ›å»ºè¯é¢˜å¹¶å†™å…¥ KVï¼škey = user:<uid>ï¼Œvalue = { thread_id, title }
async function createAndStoreTopic(from, key, env) {
  const title = buildTopicTitle(from);
  const res = await tgCall(env, 'createForumTopic', {
    chat_id: env.SUPERGROUP_ID,
    name: title
  });

  if (!res.ok) {
    throw new Error('createForumTopic failed: ' + res.description);
  }

  const threadId = res.result.message_thread_id;
  const rec = { thread_id: threadId, title, closed: false };
  await env.TOPIC_MAP.put(key, JSON.stringify(rec));
  return rec;
}

// æŒ‰ thread_id åæŸ¥ç”¨æˆ·ï¼ˆç®€å•ç‰ˆæœ¬ï¼šéå†æ‰€æœ‰ keyï¼‰
// å¦‚æœç”¨æˆ·æ¯”è¾ƒå°‘ï¼Œè¿™æ ·è¶³å¤Ÿç”¨ï¼›å¤šç”¨æˆ·æ—¶å¯ä»¥å†åš thread->user çš„åå‘ KV
async function findUserByThread(threadId, env) {
  const list = await env.TOPIC_MAP.list({ prefix: 'user:' });
  for (const { name } of list.keys) {
    const rec = await env.TOPIC_MAP.get(name, { type: 'json' });
    if (rec && Number(rec.thread_id) === Number(threadId)) {
      return Number(name.slice('user:'.length));
    }
  }
  return null;
}

// è¯é¢˜æ ‡é¢˜ï¼šæ˜µç§° + @ç”¨æˆ·åï¼ˆè‹¥æœ‰ï¼‰ï¼Œä¸å¸¦ uid
function buildTopicTitle(from) {
  const first = from.first_name || '';
  const last = from.last_name || '';
  const nick = `${first} ${last}`.trim(); // æ˜¾ç¤ºå / æ˜µç§°

  if (from.username) {
    const at = '@' + from.username;
    const title = nick ? `${nick} ${at}` : at;
    // Telegram é™åˆ¶ 128 å­—ç¬¦
    return title.slice(0, 128);
  }

  const fallback = nick || 'User';
  return fallback.slice(0, 128);
}

// Telegram API é€šç”¨è°ƒç”¨
async function tgCall(env, method, body) {
  const base = env.API_BASE || 'https://api.telegram.org';
  const url = `${base}/bot${env.BOT_TOKEN}/${method}`;
  const resp = await fetch(url, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(body)
  });
  let data;
  try {
    data = await resp.json();
  } catch {
    data = { ok: false, description: 'invalid json from telegram' };
  }
  return data;
}

// åˆ¤æ–­è¯é¢˜æ˜¯å¦å·²ä¸å­˜åœ¨ï¼ˆè¢«åˆ /çº¿ç¨‹æ— æ•ˆç­‰ï¼‰
function isThreadMissingError(res) {
  if (!res || res.ok) return false;
  const desc = (res.description || '').toUpperCase();
  return (
    desc.includes('MESSAGE THREAD NOT FOUND') ||
    desc.includes('MESSAGE_THREAD_NOT_FOUND') ||
    desc.includes('THREAD_NOT_FOUND') ||
    desc.includes('TOPIC_NOT_FOUND') ||
    desc.includes('FORUM_TOPIC_NOT_FOUND')
  );
}

// æ ‡è®°è¯é¢˜å…³é—­ / é‡æ–°å¼€å¯
async function markThreadClosed(threadId, env) {
  const list = await env.TOPIC_MAP.list({ prefix: 'user:' });
  for (const { name } of list.keys) {
    const rec = await env.TOPIC_MAP.get(name, { type: 'json' });
    if (rec && Number(rec.thread_id) === Number(threadId)) {
      rec.closed = true;
      await env.TOPIC_MAP.put(name, JSON.stringify(rec));
      break;
    }
  }
}

async function markThreadReopened(threadId, env) {
  const list = await env.TOPIC_MAP.list({ prefix: 'user:' });
  for (const { name } of list.keys) {
    const rec = await env.TOPIC_MAP.get(name, { type: 'json' });
    if (rec && Number(rec.thread_id) === Number(threadId)) {
      rec.closed = false;
      await env.TOPIC_MAP.put(name, JSON.stringify(rec));
      break;
    }
  }
}

// æ˜¯å¦å·²é€šè¿‡ Turnstile éªŒè¯
async function isVerified(uid, env) {
  const flag = await env.TOPIC_MAP.get(`verified:${uid}`);
  return Boolean(flag);
}

// Turnstile éªŒè¯é¡µé¢
function renderVerifyPage(url, env) {
  const token = url.searchParams.get('token') || '';
  const sitekey = env.TURNSTILE_SITEKEY;
  if (!sitekey || !token) return new Response('Missing token or sitekey', { status: 400 });
  const html = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>äººæœºéªŒè¯</title>
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
</head>
<body>
  <h3>è¯·å®ŒæˆäººæœºéªŒè¯</h3>
  <form method="POST" action="/verify">
    <div class="cf-turnstile" data-sitekey="${sitekey}"></div>
    <input type="hidden" name="token" value="${token}" />
    <button type="submit">æäº¤</button>
  </form>
</body>
</html>`;
  return new Response(html, { status: 200, headers: { 'content-type': 'text/html; charset=utf-8' } });
}

// å¤„ç† Turnstile æäº¤
async function handleVerifySubmit(request, env) {
  const form = await request.formData();
  const respToken = form.get('cf-turnstile-response');
  const token = form.get('token');
  if (!respToken || !token) return new Response('ç¼ºå°‘éªŒè¯ä¿¡æ¯', { status: 400 });

  const verifyRes = await fetch('https://challenges.cloudflare.com/turnstile/v0/siteverify', {
    method: 'POST',
    headers: { 'content-type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      secret: env.TURNSTILE_SECRET,
      response: respToken
    })
  });
  const data = await verifyRes.json();
  if (!data.success) {
    return new Response('éªŒè¯å¤±è´¥ï¼Œè¯·è¿”å›é‡è¯•', { status: 400 });
  }

  const record = await env.TOPIC_MAP.get(`verify:${token}`, { type: 'json' });
  if (!record || !record.uid) return new Response('éªŒè¯è¶…æ—¶æˆ–è®°å½•ä¸å­˜åœ¨', { status: 400 });

  await env.TOPIC_MAP.put(`verified:${record.uid}`, '1');
  await env.TOPIC_MAP.delete(`verify:${token}`);

  // ä¸»åŠ¨æé†’ç”¨æˆ·éªŒè¯æˆåŠŸ
  try {
    await tgCall(env, 'sendMessage', {
      chat_id: record.uid,
      text: 'âœ… äººæœºéªŒè¯æˆåŠŸï¼Œå¯ä»¥å›åˆ°å’Œæœºå™¨äººçš„ç§èŠç»§ç»­å‘é€æ¶ˆæ¯äº†ã€‚'
    });
  } catch {
    // å¿½ç•¥å‘é€å¤±è´¥
  }

  return new Response('éªŒè¯æˆåŠŸï¼Œè¯·å›åˆ° Telegram ç»§ç»­å¯¹è¯ã€‚', { status: 200 });
}
